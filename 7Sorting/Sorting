# Sorting

* 插入排序
    * **直接插入排序**
  > * 原理：从前往后以此比较a[i]和a[i-1]的大小，若发现逆序存在，则将a[i]存入到a[0]中，从i处往前遍历，找到一个合适的地方，先将后面的元素整体后移，再将a[0]插入。
  > * 细节：
  > > 1. a[0]作为哨兵存在
  > > 2. i从2开始遍历
    * **折半插入排序**
  > * 原理：从前往后以此比较a[i]和a[i-1]的大小，若发现逆序存在，则将a[i]存入到a[0]中，采用折半查找的方式，找到一个合适的地方，先将后面的元素整体后移，再将a[0]插入。
  > * 细节：
  > > 1. 折半查找不需要考虑细枝末节，与a[mid]相比顺序则low = mid + 1，逆序则high = mid -1
  > > 2. 最后访问到的结点后一个结点处为要插入的地方
    * **希尔排序**
  > * 原理：每趟插入排序的步长事先选定好（或每次除以二），到1为止，每趟排序的i++。步长是每次遍历到第i个元素时与其相隔整数倍步长的元素进行插入排序，i还是要整体遍历一遍的。
  >* 细节：
  > > 1. a[0]不作为哨兵，在插入排序寻找插入位置时，要加上j>0以防越界
  > > 2. i从1+dk开始遍历
  > * 特点
  > > 1. 增量序列应保证没有除1外的公因子，最后一个增量必须为1
* 交换排序
    * **冒泡排序**
  > * 原理：用isDone记录是否已经排好序，用count记录比较起点，每次进行两两比较，逆序则交换。
  > * 细节：
  > > 1. 每次遍历从count开始即可
    * **快速排序**
  > * 原理：每次递归low和high的范围，取第一个元素于a[0]中，若high处大于a[0]则high--，low处小于a[0]则low++，若碰到逆序则将此处元素送到另一个中，并开始另一边的遍历
  > * 细节：
  > > 1. 每次遍历时，停止的那边所在元素无意义
  > >2. 每次切换遍历要确定low是否小于high（不像折半那样有等于）
* 选择排序
    * **简单选择排序**
  > * 原理：每次选择一个最小的元素和遍历元素互换
  > * 复杂度
    * **堆排序**
  > * 原理：将数组看成完全二叉树，建立大根堆，即父结点关键字比两个子树都要大，依次将根结点a[1]与后面的结点a[i]置换，置换后在[1..i-1]内重新建堆。
  > * 细节：
  > > 1. AdjustHeap：参数为start和end，意为在[start...end]范围内进行重新建堆，将a[start]结点存储在a[0]处，通过比较a[start]下两个结点的关键字和a[0]的大小来判断是否为大根堆，若为大根堆则break，若不为大根堆则将子结点较大那个送入start里，同时令start为关键字较大那个子结点下标
  > > 2. CreatHeap：要从length/2开始向上建堆
  > >3. HeapSorting：先CreatHeap，再将第一个元素与第i个元素交换，并在[1...i-1]的范围内建堆
* 归并排序（两个或两个以上的有序表合并成一个有序表）
    * **2-路归并排序**
  > * 原理：使用递归，每次将[low...mid]和[mid+1...high]递归进行归并排序，当mid=low=high时，递归宽度为1，此时返回，返回后再将左右两边进行归并，这样就实现了宽度从1到n/2的归并
  > * 细节
  > > 1. Merge：另取一数组b，将a的值赋给b，取指针i和j对应b的两段，比较b[i]和b[j]取小者加入到a[k]中，当其中一个指针到头后，取剩余者直接加入a中。
  > > 2. MergeSort：将数组分成两段，两端分别递归，递归后对这两段进行归并操作。
* 基数排序
    * **链式基数排序**
  > * 原理：使用最低位优先法，先进行分配，再进行收集

|  算法种类   | 最好时间复杂度  | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 |  稳定性  | 是否支持链式存储 |适用情况
|  ----      |      ----    |    ----     |    ----      |   ----   | ---- |----|----
| 直接插入排序      | n        |       n^2       |     n^2         |  1| 稳定|支持|n较小且记录的信息较少、基本有序
| 折半插入排序      | nlogn        |n^2|n^2|1|稳定|难以支持|
|希尔排序| | | |1|不稳定|难以支持|
|冒泡排序|n|n^2|n^2|1|稳定|支持|基本有序
|快速排序|nlogn|nlogn|n^2|logn(最坏情况下n)|不稳定|难以支持|n较大且关键字随机分布
|简单选择排序|n^2|n^2|n^2|1|稳定(不稳定)|支持|n较小且记录的信息较多
|堆排序|nlogn|nlogn|nlogn|1|不稳定|难以支持|n较大且对空间有限制
|2-路归并排序|nlogn|nlogn|nlogn|n|稳定|支持|n较大且要求稳定
|基数排序|d(n+r)|d(n+r)|d(n+r)|r|稳定|支持|n较大且关键字可分解

* 外部排序(归并)
  > 1. 将待排序文件分成若干个子文件，并将子文件放入内存使用内部排序进行排序
  > 2. 归并：对m个初始段进行k-路平衡归并
  > > 1. 多路平衡归并
         ![多路平衡归并](多路平衡归并.png)
         利用"败者树"（胜者树）如图a，选择出关键字最小的结点b3，作为胜者取出，后b3结点关键字下延，再次选出胜者。可以在每个归并段中加入一个最大值，当选出冠军是最大值时表明归并完成。
  > > 2. 置换-选择算法（生成初始的归并段） 设待排文件为FI，初始段输出文件为FO，内存工作区为WA，WA可容纳w个记录
  > > > 1. 从FI输入w个记录到WA中
  > > > 2. 从WA中选取关键字最小的记录，记为MINIMAX（使用败者树）
  > > > 3. 将MINIMAX输出到FO中
  > > > 4. 若FI不为空，则从FI输入下一个记录到WA中
  > > > 5. 从WA中所有关键字比MINIMAX大的记录中选出最小的关键字作为新的MINIMAX
  > > > 6. 重复3-5直到选不出MINIMAX为止，由此得到一个初始归并段
  > > > 7. 重复2-6直到WA为空
           ![多路平衡归并](置换-选择算法.png)
  > > 3. 最佳归并树： 对于k叉树，有n0个结点，若(n0-1)%(k-1) == u,u==0时，刚好构成一个k叉归并树，若u!=0，则还需加上k-u-1个空叶子结点，才能构成最小归并树